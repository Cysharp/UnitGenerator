// <auto-generated>
// THIS (.cs) FILE IS GENERATED BY UnitGenerator. DO NOT CHANGE IT.
// </auto-generated>
#pragma warning disable CS8669
#pragma warning disable CS8625
#nullable enable
using System;

namespace UnitGenerator
{
    [AttributeUsage(AttributeTargets.Struct, AllowMultiple = false)]
    internal class UnitOfAttribute : Attribute
    {
        public Type Type { get; }
        public UnitGenerateOptions Options { get; }
        public string Format { get; }

        public UnitOfAttribute(Type type, UnitGenerateOptions options = UnitGenerateOptions.None, string toStringFormat = null)
        {
            this.Type = type;
            this.Options = options;
            this.Format = toStringFormat;
        }
    }
    
    [Flags]
    internal enum UnitGenerateOptions
    {
        None = 0,
        ImplicitOperator = 1,
        ParseMethod = 1 << 1,
        MinMaxMethod = 1 << 2,
        ArithmeticOperator = 1 << 3,
        ValueArithmeticOperator = 1 << 4,
        Comparable = 1 << 5,
        Validate = 1 << 6,
        JsonConverter = 1 << 7,
        MessagePackFormatter = 1 << 8,
        DapperTypeHandler = 1 << 9,
        EntityFrameworkValueConverter = 1 << 10,
        WithoutComparisonOperator = 1 << 11,
        JsonConverterDictionaryKeySupport = 1 << 12,
        Normalize = 1 << 13,
    }

    [Flags]
    internal enum UnitGenerateArithmeticOperator
    {
        Number = 0,
        Addition = 1,
        Subtraction = 1 << 1,
        Multiply = 1 << 2,
        Division = 1 << 3,
        Increment = 1 << 4,
        Decrement = 1 << 5,
    }
    
#if NET7_0_OR_GREATER
   internal static class AsNumber<T> where T : INumber<T>
   {
        public static T One => T.One;
        public static int Radix => T.Radix;
        public static T Zero => T.Zero;
        public static T Abs(T value) => T.Abs(value);
        public static bool IsCanonical(T value) => T.IsCanonical(value);
        public static bool IsComplexNumber(T value) => T.IsComplexNumber(value);
        public static bool IsEvenInteger(T value) => T.IsEvenInteger(value);
        public static bool IsFinite(T value) => T.IsFinite(value);
        public static bool IsImaginaryNumber(T value) => T.IsImaginaryNumber(value);
        public static bool IsInfinity(T value) => T.IsInfinity(value);
        public static bool IsInteger(T value) => T.IsInteger(value);
        public static bool IsNaN(T value) => T.IsNaN(value);
        public static bool IsNegative(T value) => T.IsNegative(value);
        public static bool IsNegativeInfinity(T value) => T.IsNegativeInfinity(value);
        public static bool IsNormal(T value) => T.IsNormal(value);
        public static bool IsOddInteger(T value) => T.IsOddInteger(value);
        public static bool IsPositive(T value) => T.IsPositive(value);
        public static bool IsPositiveInfinity(T value) => T.IsPositiveInfinity(value);
        public static bool IsRealNumber(T value) => T.IsRealNumber(value);
        public static bool IsSubnormal(T value) => T.IsSubnormal(value);
        public static bool IsZero(T value) => T.IsZero(value);
        public static T MaxMagnitude(T x, T y) => T.MaxMagnitude(x, y);
        public static T MaxMagnitudeNumber(T x, T y) => T.MaxMagnitudeNumber(x, y);
        public static T MinMagnitude(T x, T y) => T.MinMagnitude(x, y);
        public static T MinMagnitudeNumber(T x, T y) => T.MinMagnitudeNumber(x, y);
   }
#endif    
}
