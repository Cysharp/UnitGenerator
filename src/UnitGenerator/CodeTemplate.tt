<#@ template debug="false" hostspecific="false" language="C#" linePragmas="false" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
// <auto-generated>
// THIS (.cs) FILE IS GENERATED BY UnitGenerator. DO NOT CHANGE IT.
// </auto-generated>
#pragma warning disable CS8669
using System;
<# if (HasFlag(UnitGenerateOptions.MessagePackFormatter)) { #> 
using MessagePack;
using MessagePack.Formatters;
<# } #>
<# if (HasFlag(UnitGenerateOptions.JsonConverter)) { #> 
using System.Text.Json;
using System.Text.Json.Serialization;
<# } #>
<# if (HasFlag(UnitGenerateOptions.DapperTypeHandler)) { #> 
using System.Runtime.CompilerServices;
<# } #>

<# if (!string.IsNullOrEmpty(Namespace)) { #>
namespace <#= Namespace #>
{
<# } #>
<# if (HasFlag(UnitGenerateOptions.JsonConverter)) { #> 
    [JsonConverter(typeof(<#= Name #>JsonConverter))]
<# } #>
<# if (HasFlag(UnitGenerateOptions.MessagePackFormatter)) { #> 
    [MessagePackFormatter(typeof(<#= Name #>MessagePackFormatter))]
<# } #>
    [System.ComponentModel.TypeConverter(typeof(<#= Name #>TypeConverter))]
    readonly partial struct <#= Name #> : IEquatable<<#= Name #>> <#= HasFlag(UnitGenerateOptions.Comparable) ? $", IComparable<{Name}>" : "" #>
    {
        readonly <#= Type #> value;

        public <#= Type #> AsPrimitive() => value;

        public <#= Name #>(<#= Type #> value)
        {
            this.value = value;
<# if (HasFlag(UnitGenerateOptions.Validate)) { #> 
            this.Validate();
<# } #>
        }

<# if (HasFlag(UnitGenerateOptions.Validate)) { #> 
        private partial void Validate();
<# } #>

        public static <#= HasFlag(UnitGenerateOptions.ImplicitOperator) ? "implicit" : "explicit" #> operator <#= Type #>(<#= Name #> value)
        {
            return value.value;
        }

        public static <#= HasFlag(UnitGenerateOptions.ImplicitOperator) ? "implicit" : "explicit" #> operator <#= Name #>(<#= Type #> value)
        {
            return new <#= Name #>(value);
        }

        public bool Equals(<#= Name #> other)
        {
            return value.Equals(other.value);
        }

        public override bool Equals(object obj)
        {
            if (obj == null) return false;
            var t = obj.GetType();
            if (t == typeof(<#= Name #>))
            {
                return Equals((<#= Name #>)obj);
            }
            if (t == typeof(<#= Type #>))
            {
                return value.Equals((<#= Type #>)obj);
            }

            return value.Equals(obj);
        }

        public override int GetHashCode()
        {
            return value.GetHashCode();
        }

        public override string ToString()
        {
<# if (ToStringFormat == null) { #>
            return value.ToString();
<# } else { #>
            return string.Format("<#= ToStringFormat #>", value);
<# } #>
        }

        public static bool operator ==(in <#= Name #> x, in <#= Name #> y)
        {
            return x.value.Equals(y.value);
        }

        public static bool operator !=(in <#= Name #> x, in <#= Name #> y)
        {
            return !x.value.Equals(y.value);
        }

<# if (Type == "Guid" || Type == "System.Guid") { #>
        public static readonly <#= Name #> Empty = default(<#= Name #>);

        public static <#= Name #> New()
        {
            return new <#= Name #>(Guid.NewGuid());
        }

        public static <#= Name #> New<#= Name #>()
        {
            return new <#= Name #>(Guid.NewGuid());
        }

<# } #>

<# if (Type == "Ulid" || Type == "System.Ulid") { #>
        public static readonly <#= Name #> Empty = default(<#= Name #>);
        
        public static <#= Name #> New()
        {
            return new <#= Name #>(Ulid.NewUlid());
        }

        public static <#= Name #> New<#= Name #>()
        {
            return new <#= Name #>(Ulid.NewUlid());
        }

<# } #>

<# if (HasFlag(UnitGenerateOptions.ParseMethod)) { #> 
        // UnitGenerateOptions.ParseMethod

        public static <#= Name #> Parse(string s)
        {
<# if (Type == "string") { #>
            return new <#= Name #>(s);
<# } else { #>
            return new <#= Name #>(<#= Type #>.Parse(s));
<# } #>
        }
        
        public static bool TryParse(string s, out <#= Name #> result)
        {
<# if (Type == "string") { #>
            try
            {
                result = Parse(s);    
                return true;
            } 
            catch 
            {
                result = default;
                return false;
            }
<# } else { #>
            if(<#= Type #>.TryParse(s, out var r))
            {
                result = new <#= Name #>(r);
                return true;
            }
            else
            {
                result = default(<#= Name #>);
                return false;
            }
<# } #>
        }

<# } #>

<# if (HasFlag(UnitGenerateOptions.MinMaxMethod)) { #> 
        // UnitGenerateOptions.MinMaxMethod

        public static <#= Name #> Min(<#= Name #> x, <#= Name #> y)
        {
            return new <#= Name #>(Math.Min(x.value, y.value));
        }

        public static <#= Name #> Max(<#= Name #> x, <#= Name #> y)
        {
            return new <#= Name #>(Math.Max(x.value, y.value));
        }

<# } #>

<# if (Type == "bool") { #>
        // Default

        public static <#= Type #> operator true(<#= Name #> x)
        {
            return x.value;
        }
        
        public static <#= Type #> operator false(<#= Name #> x)
        {
            return !x.value;
        }
        
        public static <#= Type #> operator !(<#= Name #> x)
        {
            return !x.value;
        }

<# } #>

<# if (HasFlag(UnitGenerateOptions.ArithmeticOperator)) { #> 
        // UnitGenerateOptions.ArithmeticOperator

        public static <#= Name #> operator +(in <#= Name #> x, in <#= Name #> y)
        {
            checked
            {
                return new <#= Name #>((<#= Type #>)(x.value + y.value));
            }
        }

        public static <#= Name #> operator -(in <#= Name #> x, in <#= Name #> y)
        {
            checked
            {
                return new <#= Name #>((<#= Type #>)(x.value - y.value));
            }
        }

        public static <#= Name #> operator *(in <#= Name #> x, in <#= Name #> y)
        {
            checked
            {
                return new <#= Name #>((<#= Type #>)(x.value * y.value));
            }
        }

        public static <#= Name #> operator /(in <#= Name #> x, in <#= Name #> y)
        {
            checked
            {
                return new <#= Name #>((<#= Type #>)(x.value / y.value));
            }
        }

<# } #>

<# if (HasFlag(UnitGenerateOptions.ValueArithmeticOperator)) { #> 
        // UnitGenerateOptions.ValueArithmeticOperator

        public static <#= Name #> operator ++(in <#= Name #> x)
        {
            checked
            {
                return new <#= Name #>((<#= Type #>)(x.value + 1));
            }
        }

        public static <#= Name #> operator --(in <#= Name #> x)
        {
            checked
            {
                return new <#= Name #>((<#= Type #>)(x.value - 1));
            }
        }

        public static <#= Name #> operator +(in <#= Name #> x, in <#= Type #> y)
        {
            checked
            {
                return new <#= Name #>((<#= Type #>)(x.value + y));
            }
        }

        public static <#= Name #> operator -(in <#= Name #> x, in <#= Type #> y)
        {
            checked
            {
                return new <#= Name #>((<#= Type #>)(x.value - y));
            }
        }

        public static <#= Name #> operator *(in <#= Name #> x, in <#= Type #> y)
        {
            checked
            {
                return new <#= Name #>((<#= Type #>)(x.value * y));
            }
        }

        public static <#= Name #> operator /(in <#= Name #> x, in <#= Type #> y)
        {
            checked
            {
                return new <#= Name #>((<#= Type #>)(x.value / y));
            }
        }

<# } #>

<# if (HasFlag(UnitGenerateOptions.Comparable)) { #> 
        // UnitGenerateOptions.Comparable

        public int CompareTo(<#= Name #> other)
        {
            return value.CompareTo(other.value);
        }

<# if (!HasFlag(UnitGenerateOptions.WithoutComparisonOperator)) { #>         
        
        public static bool operator >(in <#= Name #> x, in <#= Name #> y)
        {
            return x.value > y.value;
        }

        public static bool operator <(in <#= Name #> x, in <#= Name #> y)
        {
            return x.value < y.value;
        }

        public static bool operator >=(in <#= Name #> x, in <#= Name #> y)
        {
            return x.value >= y.value;
        }

        public static bool operator <=(in <#= Name #> x, in <#= Name #> y)
        {
            return x.value <= y.value;
        }
<# } #>

<# } #>

<# if (HasFlag(UnitGenerateOptions.JsonConverter)) { #> 
        // UnitGenerateOptions.JsonConverter
        private class <#= Name #>JsonConverter : JsonConverter<<#= Name #>>
        {
            public override void Write(Utf8JsonWriter writer, <#= Name #> value, JsonSerializerOptions options)
            {
                var converter = options.GetConverter(typeof(<#= Type #>)) as JsonConverter<<#= Type #>>;
                if (converter != null)
                {
                    converter.Write(writer, value.value, options);
                }
                else
                {
                    throw new JsonException($"{typeof(<#= Type #>)} converter does not found.");
                }
            }
        
            public override <#= Name #> Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
            {
                var converter = options.GetConverter(typeof(<#= Type #>)) as JsonConverter<<#= Type #>>;
                if (converter != null)
                {
                    return new <#= Name #>(converter.Read(ref reader, typeToConvert, options));
                }
                else
                {
                    throw new JsonException($"{typeof(<#= Type #>)} converter does not found.");
                }
            }

<#if (HasFlag(UnitGenerateOptions.JsonConverterDictionaryKeySupport)) {  #>
            public override void WriteAsPropertyName(Utf8JsonWriter writer, <#= Name #> value, JsonSerializerOptions options)
            {
<#if (IsSupportUtf8Formatter()) {  #>
                Span<byte> buffer = stackalloc byte[36];
                if (System.Buffers.Text.Utf8Formatter.TryFormat(value.value, buffer, out var written))
                {
                    writer.WritePropertyName(buffer.Slice(0, written));
                }
                else
                {
                    writer.WritePropertyName(value.value.ToString());
                }
<# } else if (IsUlid()) { #>
                writer.WritePropertyName(value.value.ToString());
<# } else { #>
                writer.WritePropertyName(value.value.ToString());
<# } #>
            }

            public override <#= Name #> ReadAsPropertyName(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
            {
<#if (IsSupportUtf8Formatter()) {  #>
                if (System.Buffers.Text.Utf8Parser.TryParse(reader.ValueSpan, out <#= Type #> value, out var consumed))
                {
                    return new <#= Name #>(value);
                }
                else
                {
                    return new <#= Name #>(<#= Type #>.Parse(reader.GetString()));
                }
<# } else if (IsUlid()) { #>
                return new <#= Name #>(<#= Type #>.Parse(reader.GetString()));
<# } else if(Type == "string")  { #>
                    return new <#= Name #>(reader.GetString());
<# } else { #>
                return new <#= Name #>(<#= Type #>.Parse(reader.GetString()));
<# } #>
            }

<# } #>

        }

<# } #>

<# if (HasFlag(UnitGenerateOptions.MessagePackFormatter)) { #> 
        // UnitGenerateOptions.MessagePackFormatter
        private class <#= Name #>MessagePackFormatter : IMessagePackFormatter<<#= Name #>>
        {
            public void Serialize(ref MessagePackWriter writer, <#= Name #> value, MessagePackSerializerOptions options)
            {
                options.Resolver.GetFormatterWithVerify<<#= Type #>>().Serialize(ref writer, value.value, options);
            }

            public <#= Name #> Deserialize(ref MessagePackReader reader, MessagePackSerializerOptions options)
            {
                return new <#= Name #>(options.Resolver.GetFormatterWithVerify<<#= Type #>>().Deserialize(ref reader, options));
            }
        }

<# } #>

<# if (HasFlag(UnitGenerateOptions.DapperTypeHandler)) { #> 
        // UnitGenerateOptions.DapperTypeHandler
        public class <#= Name #>TypeHandler : Dapper.SqlMapper.TypeHandler<<#= Name #>>
        {
            public override <#= Name #> Parse(object value)
            {
                return new <#= Name #>((<#= Type #>)value);
            }

            public override void SetValue(System.Data.IDbDataParameter parameter, <#= Name #> value)
            {
                parameter.DbType = System.Data.DbType.<#= GetDbType() #>;
                parameter.Value = value.value;
            }
        }

        [ModuleInitializer]
        public static void AddTypeHandler()
        {
            Dapper.SqlMapper.AddTypeHandler(new <#= Name #>.<#= Name #>TypeHandler());
        }
<# } #>

<# if (HasFlag(UnitGenerateOptions.EntityFrameworkValueConverter)) { #> 
        // UnitGenerateOptions.EntityFrameworkValueConverter
        public class <#= Name #>ValueConverter : Microsoft.EntityFrameworkCore.Storage.ValueConversion.ValueConverter<<#= Name #>, <#= Type #>>
        {
            public <#= Name #>ValueConverter()
                : base(
                        convertToProviderExpression: x => x.value,
                        convertFromProviderExpression: x => new <#= Name #>(x))
            {
            }

            public <#= Name #>ValueConverter(Microsoft.EntityFrameworkCore.Storage.ValueConversion.ConverterMappingHints mappingHints = null)
                : base(
                        convertToProviderExpression: x => x.value,
                        convertFromProviderExpression: x => new <#= Name #>(x),
                        mappingHints: mappingHints)
            {
            }
        }

<# } #>
        // Default
        private class <#= Name #>TypeConverter : System.ComponentModel.TypeConverter
        {
            private static readonly Type WrapperType = typeof(<#= Name #>);
            private static readonly Type ValueType = typeof(<#= Type #>);

            public override bool CanConvertFrom(System.ComponentModel.ITypeDescriptorContext context, Type sourceType)
            {
                if (sourceType == WrapperType || sourceType == ValueType)
                {
                    return true;
                }

                return base.CanConvertFrom(context, sourceType);
            }

            public override bool CanConvertTo(System.ComponentModel.ITypeDescriptorContext context, Type destinationType)
            {
                if (destinationType == WrapperType || destinationType == ValueType)
                {
                    return true;
                }

                return base.CanConvertTo(context, destinationType);
            }

            public override object ConvertFrom(System.ComponentModel.ITypeDescriptorContext context, System.Globalization.CultureInfo culture, object value)
            {
                if (value != null)
                {
                    var t = value.GetType();
                    if (t == typeof(<#= Name #>))
                    {
                        return (<#= Name #>)value;
                    }
                    if (t == typeof(<#= Type #>))
                    {
                        return new <#= Name #>((<#= Type #>)value);
                    }
                }

                return base.ConvertFrom(context, culture, value);
            }

            public override object ConvertTo(System.ComponentModel.ITypeDescriptorContext context, System.Globalization.CultureInfo culture, object value, Type destinationType)
            {
                if (value is <#= Name #> wrappedValue)
                {
                    if (destinationType == WrapperType)
                    {
                        return wrappedValue;
                    }

                    if (destinationType == ValueType)
                    {
                        return wrappedValue.AsPrimitive();
                    }
                }

                return base.ConvertTo(context, culture, value, destinationType);
            }
        }
    }
<# if (!string.IsNullOrEmpty(Namespace)) { #>
}
<# } #>